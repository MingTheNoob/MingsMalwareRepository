	.386
	.model flat, stdcall
	option casemap :none

	include \MASM32\INCLUDE\windows.inc
	include \MASM32\INCLUDE\kernel32.inc
	include \MASM32\INCLUDE\user32.inc
	
	includelib \MASM32\LIB\kernel32.lib
	includelib \MASM32\LIB\user32.lib
		

_OPCODE struct
	dwOldAddress	dd	?	; Старый адрес инструкции (до морфинга)
	dwNewAddress	dd	?	; Новый адрес инструкции  (после морфинга)
	dwJumpAddress	dd	?	; Адрес куда должен указывать прыжок(или вызов)
						; (если инструкция им является)
	dwLength		dd	?	; в данном примере эта переменная не используется
	 					; Надеюсь вам она пригодиться больше чем мне :)
_OPCODE ends
	
; #########################################################################

.code

test_code:
	@@:
	jmp @F
	mov eax, edx
	pop eax
	push eax
	call @F
	cmp eax, 0
	jne @B
	jmp @B
	add ecx, edx
	add eax, edx
	xchg edx, ecx
	call @B
	jne @F
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0
	jne @B
	ret
	@@:
	ret
	int 3
	
include Catchy32\Catchy32.inc

get_jump_address proc dwCurrentAddress : DWORD

	push ecx
	push edi

	mov edi, dwCurrentAddress
	mov al, byte ptr [edi]

	cmp al, 070h
	jl @F
	cmp al, 07Fh
	jna @_jump_imm8_
	
@@:
	cmp al, 0EBh
	je @_jump_uncond_imm8_
	cmp al, 00Fh
	jne @F
	mov ah, byte ptr [edi + 1]
	cmp ah, 080h
	jl @F
	cmp ah, 08Fh
	jna @_jump_imm32_

@@:	
	cmp al, 0E9h
	je @_jump_uncond_imm32_
	
	cmp al, 0E8h
	je @_call_imm32_
	
	jmp @_exit_

@_jump_imm8_:
@_jump_uncond_imm8_:
	movzx eax, byte ptr [edi + 1]
	mov cl, al
	test cl, 10000000b
	
	jnz @_neg_1
		add edi, eax
		add edi, 2
		xchg eax, edi
		jmp @_exit_
	
	@_neg_1:
		neg al
		sub al, 2
		sub edi, eax
		xchg eax, edi
		jmp @_exit_	

	
@_jump_imm32_:
	mov eax, dword ptr [edi + 2]
	mov ecx, eax
	shr ecx, 24d
	test ecx, 10000000b
	
	jnz @_neg_2
		add eax, edi
		add eax, 6
		jmp @_exit_
		
	@_neg_2:
		neg eax
		sub eax, 6
		sub edi, eax
		xchg eax, edi
		jmp @_exit_

@_jump_uncond_imm32_:
@_call_imm32_:
	mov eax, dword ptr [edi + 1]
	mov ecx, eax
	shr ecx, 24d
	test ecx, 10000000b
	
	jnz @_neg_3
		add edi, eax
		add edi, 5
		xchg eax, edi
		jmp @_exit_
		
	@_neg_3:
		neg eax
		sub eax, 5
		sub edi, eax
		xchg eax, edi
@_exit_:
	
	pop edi
	pop ecx

	ret
get_jump_address endp

get_new_jump_address proc dwAddress:DWORD, pOpcodes : DWORD
	push ecx
	
	assume ecx : ptr _OPCODE
	mov ecx, pOpcodes
	mov eax, dwAddress
	
	@@:
	cmp [ecx].dwOldAddress, eax
	je @F
	add ecx, sizeof _OPCODE
	cmp [ecx].dwOldAddress, 0
	jne @B
	xor eax, eax
	@@:
	mov eax, [ecx].dwNewAddress
	
	pop ecx
	ret
get_new_jump_address endp

MorphCode proc dwCodeAddress	: DWORD, dwOutputBuffer : DWORD
local pOpcodes			: DWORD
local dwTotalCodeSize		: DWORD

	invoke VirtualAlloc, NULL, 1024*1024, MEM_COMMIT + MEM_RESERVE, PAGE_READWRITE
	mov pOpcodes, eax
	
	push 0
	pop dwTotalCodeSize
	
	assume ecx : ptr _OPCODE
	mov esi, dwCodeAddress	; Code Address
	mov edi, dwOutputBuffer	; New Code Address
	mov ecx, pOpcodes		; array of _OPCODES
	
	mov [ecx].dwNewAddress, edi

	@_loop_1:

	call c_Catchy

	mov [ecx].dwOldAddress, esi
	mov [ecx].dwLength, eax

	cmp byte ptr [esi], 070h
	jl @F
	cmp byte ptr [esi], 07Fh
	ja @F
		push eax
		mov al, 00Fh
		stosb
		
		movzx eax, byte ptr [esi]
		add eax, 10h
		stosd	

		push esi
		call get_jump_address
		
		mov [ecx].dwJumpAddress, eax
		
		pop eax

		add dwTotalCodeSize, 6
		
	jmp @_next_inst_	
	
	@@:

	cmp byte ptr [esi], 0EBh
	jne @F
		push eax
		
		mov al, 0E9h
		stosb
		xor eax, eax
		stosd

		push esi
		call get_jump_address
		

		mov [ecx].dwJumpAddress, eax

		pop eax		

		add dwTotalCodeSize, 5		
	jmp @_next_inst_

	
	
	@@:
	cmp byte ptr [esi], 0E9h
	jne @F

	push eax
	push esi
	call get_jump_address
	mov [ecx].dwJumpAddress, eax
	pop eax
	jmp @_replace_instr_
	
	@@:	
	cmp byte ptr [esi], 0E8h
	jne @F
	
	push eax
	push esi
	call get_jump_address
	mov [ecx].dwJumpAddress, eax
	pop eax
	jmp @_replace_instr_
	
	
	@@:
	cmp byte ptr [esi], 00Fh
	jne @F
	cmp byte ptr [esi + 1], 080h
	jl @F
	cmp byte ptr [esi + 1], 08Fh
	ja @F
		push eax
		push esi
		call get_jump_address
		mov [ecx].dwJumpAddress, eax
		pop eax		

	@@:

@_replace_instr_:
	push esi
	push ecx
	
	mov ecx, eax
	rep movsb
	
	pop ecx
	pop e
